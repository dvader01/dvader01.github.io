---
layout: post
title: "Inspect - println no more"
date: 2014-11-14 17:06
comments: true
categories: 
---
**TL;DR**: I realized how strongly I **disliked** the process of **logging data structures** to the console and then trying to find them and repeatedly commenting out and uncommenting **println** statements. So I decided to **fix that**.

<!-- more -->

Last Friday, I was thinking about how to approach the next task in the **[BirdWatch](https://github.com/matthiasn/BirdWatch)** application. There, I want to do **aggregations** on data from ElasticSearch on the server side and then send the aggregate on the wire over **[WebSockets](http://en.wikipedia.org/wiki/WebSocket)** to a **[ClojureScript](https://github.com/clojure/clojurescript)** client. In order to build up the aggregate data structures, I would need to inspect what I'm building during development. But I didn't have a good way to do so.

Sure, **println** statements can be useful when reasoning about parts of an application. Just leaving them in there is **not feasible** though, particularly when running the application under any kind of load. Finding a logged item on the console can easily be like trying to find a needle in a haystack. For example in BirdWatch, my current configuration receives around **50 tweets per second**. I am also using this configuration for the development process. Do I want to log this relatively large tweet data structure every time, 50 times a second? **Certainly not**, that would make everything else difficult to find (an unnecessarily file the file system). Occasionally, though, I want to see one of those, or any other kind of data structure used in the system.

So what do we usually do? I constantly found myself commenting out and uncommenting log statements and then restarting the application. That's not fun at all and a **huge waste of time**.

Here's my idea for a better way of doing this: what if we can leave all those log statements in there and send them to a subsystem that can easily be integrated into **any existing Clojure application** and that takes care of the presentation? This subsystem as a **default does nothing** with the logged data, making it very cheap to even process higher loads. This system then exposes a **web application** that allows clients to see the **next n** of a certain event type (or combinations thereof). Here's how that looks like:

<a href="http://inspect.matthiasnehlsen.com" target="_blank"><img src="/images/inspect1.png" /></a>

When you connect a new client, as a default you currently get the **next 10** of every message type known to the system. On the left, there is a table that shows how many items each are remaining. On the right of the table, there are buttons that toggle if the respective data type is to be shown or not. The **next** button will increment the number for each selected type by whatever is in the field.

You can click on the image for a live version. In this simple example, there are a couple of message types:

* **:interval-put/every-millisecond** - emitted every millisecond by a go-loop
* **:interval-put/every-second** - emitted every second by a go-loop
* **:interval-put/every-five-seconds** - emitted every five seconds by a go-loop
* **:interval-put/every-ten-seconds** - emitted every ten seconds by a go-loop
* **:interval-put/every-minute** - emitted every minute by a go-loop
* **:ws/event-in** - emitted when there's an incoming message on a WebSocket connection (such as a new connection)

Using the **inspect** library is super simple. All you need to do is add **inspect** to the dependencies in your project.clj:

    [com.matthiasnehlsen/inspect "0.1.1"]

Then, you probably want to import it where you need it:

    [com.matthiasnehlsen.inspect :as inspect :refer [inspect]]

Next, you want to start it once, from anywhere:

    (inspect/start)

That's all, now you can use it, for example:

    (inspect :interval-put/every-second {:msg "every second"})

There is no need to make the event types know to inspect, other than just passing namespaced keywords. Inspect will then learn the event types itself.

Here is the full example application (minus the namespace definition, optional port configuration and REPL reload, click on the link in the upper right of the code block for the entire file):

{% codeblock inspect sample application lang:clojure https://github.com/matthiasn/inspect/blob/65feac4f2bddc9711c7e5798020c3f0b993407a0/example/src/example/core.clj core.clj%}
(defn interval-put-loop
  "put msg on chan every interval milliseonds"
  [interval msg-type msg]
  (go-loop [] (<! (timeout interval)) (inspect msg-type msg) (recur)))

(interval-put-loop     1 :interval-put/every-millisecond {:msg "every millisecond"})
(interval-put-loop  1000 :interval-put/every-second {:msg "every second"})
(interval-put-loop  5000 :interval-put/every-five-seconds {:msg "every five seconds"})
(interval-put-loop 10000 :interval-put/every-ten-seconds {:msg "every ten seconds"})
(interval-put-loop 60000 :interval-put/every-minute {:msg "every minute"})

(defn -main [& args]
  (pid/save "example.pid")
  (pid/delete-on-shutdown! "example.pid")
  (log/info "Application started, PID" (pid/current))
  (inspect/start))
{% endcodeblock %}




Okay, this is it for today. This project is less than a week old and I am still in the middle of exploring the problem space. In particular, I want to start using it everywhere in my BirdWatch project so that I can get a better idea of how I want to interact with the UI. I think this makes for a useful executable documentation of your system, where you can easily find out how the data in your system looks like. I would have loved to have that in the past when I was new in a project.

Despite this project being so young, there is no reason why you couldn't try it already. Maybe you have ideas on what you'd like to see in there. I already a few issues on GitHub for potential improvements.

Over the next weeks, I will show how to use this inside a real application. Also, I might write an article how **inspect** works internally. Of course the code is on GitHub. It's pretty short, the entire thing including the UI is only around 300 lines of Clojure ClojureScript.



The **inspect** function can be used like a log statement, with an additional **namespaced keyword** to tell the inspect library what kind of a message it receives. Unless **start** is called once (from anywhere), inspect is a **no-op** so it should be possible to not uncomment the statements even in production.

It may even possible to keep the inspect subsystem running in production and thus monitoring what is flowing through the system. Matching events with clients does not cause a lot of extra work. In the example application, I am hitting the system with 1,000 messages per second and the extra load to match the messages with connected clients is about 3-5% (out of a total of 800% on my Retina MacBook). But this would have to be verified, of course.


If you wonder about the next steps in the design of this application, you can subscribe to the <a href="http://eepurl.com/y0HWv" target="_blank"><strong>newsletter</strong></a> or **[follow me on Twitter](https://twitter.com/matthiasnehlsen)** and I will let you know when the next article is out.

Cheers and have a great weekend,<br>
Matthias


Then in the component filtering messages, the default is a no-op, simply ignoring the message unless there’s a client requesting this type, with a decreasing counter of remaining items.

In the default scenario when no client wants messages, the extra burden should be minimal. There shouldn’t even be significant GC pressure as the evaluated immutable data structures exist already and are structurally shared. Nothing I’d be too worried about at this point. The pleasant side effect of this fact is that the inspector could be potentially run all the time, allowing peeking into a production system. The inspector system is even bringing its own HTTP server, listening on a configurable port. Thus, the main application doesn’t even require having anything to do with the web.

