
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>BirdWatch with ClojureScript and Om explained, Part 1 - Matthias Nehlsen</title>
  <meta name="author" content="Matthias Nehlsen">

  
  <meta name="description" content="This article is currently Work in Progress Last week I wrote about having written my first actual application using ClojureScript and Om, a web &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://matthiasnehlsen.com/blog/2014/07/24/BirdWatch-in-ClojureScript-1">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Matthias Nehlsen" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,400,600,300,700' rel='stylesheet' type='text/css'>

<script src="//use.typekit.net/rco1jij.js"></script>
<script>try{Typekit.load();} catch (e){}</script>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-40261983-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Matthias Nehlsen</a></h1>
  
    <h2>Software, Data and Stuff</h2>
    
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:matthiasnehlsen.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">BirdWatch with ClojureScript and Om explained, Part 1</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-24T08:30:00+02:00" pubdate data-updated="true">07/24/2014</time>
        
      </p>
    
  </header>


<div class="entry-content"><p><strong>This article is currently Work in Progress</strong></p>

<p><strong><a href="http://matthiasnehlsen.com/blog/2014/07/17/BirdWatch-in-ClojureScript/">Last week</a></strong> I wrote about having written my first actual application using <strong><a href="https://github.com/clojure/clojurescript">ClojureScript</a></strong> and <strong><a href="https://github.com/swannodette/om">Om</a></strong>, a web client for my <strong><a href="http://birdwatch.matthiasnehlsen.com/cljs/#*">BirdWatch</a></strong> application. This week I first want to talk about my experience with ClojureScript and Om thus far. Then I want to go into part 1 of the implementation details. I am fully aware that what has come out of it thus far is far from elegant in terms of pretty much everything. But in my defense, it does appear to work :)</p>

<!-- more -->


<p>So my experience. I have been reading articles and books about <strong><a href="http://clojure.org">Clojure</a></strong> for a while and it did seem to resonate with me. I like this whole <strong><a href="http://en.wikipedia.org/wiki/Homoiconicity">homoiconicity</a></strong> thing. Code and data are basically the same thing and they thus share the same data structures. Code is really data, representing the <strong><a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract syntax tree (AST)</a></strong> directly. Now my initial reaction to this concept was that it must be rather low-level to do so, but to my surprise the opposite is true with a <strong><a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a></strong>; you gain a tremendous amount of expressiveness. I also really like that <strong>a)</strong> Clojure introduces <strong><a href="http://clojure.org/data_structures">additional data structures</a></strong> besides the obvious <strong>list</strong>, i.e. Maps, Sets and Vectors and <strong>b)</strong> that it is idiomatic to simply use those.</p>

<p>Sure, there is something to be said about types and how <strong><a href="http://en.wikipedia.org/wiki/Type_safety">type safety</a></strong> makes working on large-scale applications less error-prone. But at the same time I have a hunch that having hundreds of (case) classes complects an application in a way that idiomatic usage of a map does not. Have you seen this before, where you have cascades of only slightly differing data structures, when the next step of a computation adds only a little bit of data and calls that a new thing, modeled as a different something? That can become difficult to reason about, particularly when there are no useful design documents outlining how one morphs into the other.</p>

<p>But then again I am somewhat afraid of the lack of compile time errors when I call a function with something of a wrong type. So as of now, that is an unsolved question for me. May my endeavor into Clojure and thus Lisp afford me with a more educated opinion on this matter. Against strongly typed systems I have to say that I have seen way too many runtime failures that <strong>a)</strong> the type system and the compiler did not catch and <strong>b)</strong> really came from the application being so incidentally complex that the consequences of changes were by all means hard to grasp even for the most senior team members.</p>

<p>I guess I really need some production experience with Clojure in order to get to a fair and substantial comparison of the different apporaches. But at least this application is a start. And learning a new language has never hurt anyone, I guess.</p>

<p>So how is this going as an experience so far, you might ask.</p>

<p>Here are my perceived pros:</p>

<ul>
<li>When crafting functions in Clojure, I just feel more like playing an instrument. It feels more playful.</li>
<li>Code tends to be short and concise.</li>
<li>The core of the language is easily understood, at least as far as my limited understanding goes.</li>
<li>Immutability is great, no more thinking about concurrency issues and mutating state in different places.</li>
<li>Om uses Facebook&#8217;s ReactJS, a UI rendering library that I have tried out previously and that I am somewhat familiar with.</li>
<li>Refactoring is fun, I have found spotting repetitive parts among functions and then factoring these parts out into new and shared functions not only easier compared to other languages but also pleasant.</li>
<li>Maps and sets and, by importing an external library in the case of this application, priority maps are a great thing to have, much nicer than only having JavaScript arrays and objects at your disposal.</li>
<li>Time and time again I am amazed that replacing an external dependency with a newer version generally seems to work in Clojure. This is the complete opposite of my experience in Scala. I has gotten better over the last year with Scala for sure, but it is nowhere near as smooth as it appears to be with Clojure. Why do you think that is?</li>
</ul>


<p>Here are some cons, as well:</p>

<ul>
<li>As of now, I feel like I can be more productive with plain JavaScript and ReactJS in comparison to Om. This is specific to UI problems, with general data manipulation I feel I am in the process of becoming more productive with Clojure already when compared to JavaScript and <strong><a href="http://underscorejs.org">underscore</a></strong> and definitely more productive than with plain JavaScript <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></li>
<li>Testing. I have tried out <strong><a href="http://cemerick.com">Chas Emerick</a></strong>&#8217;s <strong><a href="https://github.com/cemerick/clojurescript.test">clojurescript.test</a></strong> and while it seems do do its job alright, I don&#8217;t feel I have fully figured out how to use it. I am using it with the <strong><a href="https://github.com/cemerick/clojurescript.test#using-with-lein-cljsbuild">leiningen test runner</a></strong> and there are two things I find less than pleasing. First, every time I call <em>lein test</em> a full compile is started, even if I have <em>lein cljsbuild auto</em> for the <em>test</em> task running in another terminal window. This seems unnecessary. Am I missing something, maybe watch and re-run the tests automatically when file system changes are detected? Second, the output is plain black and white. How am I supposed to do <strong><a href="http://www.jamesshore.com/Blog/Red-Green-Refactor.html">red-green refactoring</a></strong> with this? But seriously, this might be mostly cosmetic but still I like to see green in my tests as that soothes my mind. When I see red in tests, my alertness level goes up. Black and white output excites none of these emotions. Is there just something wrong with my installation or vision that I don&#8217;t see colors in my test output?</li>
<li>Performance. The application so far is MUCH slower than the JavaScript counterpart. When processing preloaded tweets, the plain JavaScript version (used in the <strong><a href="http://birdwatch.matthiasnehlsen.com/angular/#/">AngularJS</a></strong> and <strong><a href="http://birdwatch.matthiasnehlsen.com/#/">ReactJS</a></strong> clients) is probably ten times as fast. Click those previous links and see what I mean. The previous tweets are loaded by an Ajax call in chunks of 500 items and loading and processing each chunk takes maybe a second. Now when you open the <strong><a href="http://birdwatch.matthiasnehlsen.com/cljs/#*">ClojureScript version</a></strong>, you see that it takes much longer to process the previous items. I suspect keywordizing the JSON when converting a tweet to a Clojure Map could be the problem, but I don&#8217;t know for sure. Please enlighten me and, better yet, suggest a more performant way of ingesting the JSON.</li>
<li>Application state in a single large map stored in an <strong><a href="http://clojure.org/atoms">atom</a></strong> can be cumbersome, I would not mind having something like objects here and there. I am not terribly happy with this, I have to admit, but it did seem to be what is going on in the Om tutorials. I have looked at <strong><a href="http://stuartsierra.com">Stuart Sierra</a></strong>&#8217;s <strong><a href="https://github.com/stuartsierra/component">component library</a></strong> and it does seem to offer a good approach to compenentizing the application, but I have yet to find the time to try it out.</li>
<li>Interacting with the state from inside Om is different than interacting with the state atom from other parts of the application. <strong><a href="https://github.com/Prismatic/om-tools">Om-tools</a></strong> seem to be an interesting way around this, will need to give that a try and see if that feels good.</li>
</ul>


<p>By the way, regarding performance, I have seen the same problems with my naïve Scala.js approach before. I have not played around with that one again yet ever since my first attempt back in January. That is mostly for the lack of a ReactJS binding that is anywhere near as complete as Om. I&#8217;ll be happy to give it a try again once ReactJS support is better.</p>

<h1>Introduction to Clojure</h1>

<p>First of all, you will need to understand a few very basic things about Clojure being a <strong><a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">Lisp</a></strong> <sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>. Feel free to skip this section if you know the basics already. I hope you will be able to follow along even if you&#8217;ve never tried Clojure or a Lisp before. So the basic idea in a Lisp is the List (no wonder, as Lisp stands for List Programming), a <strong><a href="http://en.wikipedia.org/wiki/Singly_linked_list#Singly_linked_lists">singly linked list</a></strong>, to be precise. This list can hold both code and data. Let&#8217;s see how that looks like. You can try these examples out using the <strong><a href="http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a></strong> in <strong><a href="http://leiningen.org">Leiningen</a></strong> by running <code>lein repl</code> from your command line.</p>

<p>This is an empty list: <code>()</code> It evaluates to itself.</p>

<p>When the list is not empty, the first item in the list will be evaluated: <code>(some-function "a" "b")</code>
Here, <em>some-function</em> will be called with the two arguments &#8220;a&#8221; and &#8220;b&#8221;. Example <code>(print "Hello World!")</code> Sweet, that&#8217;s all there is to <strong><a href="http://en.wikipedia.org/wiki/Hello_world_program">Hello World</a></strong>.</p>

<p>The first item in a list has to implement the <em>IFn</em> interface meaning it must be possible to call the item as a function. Try this: <code>("a" "b")</code>. Not surprisingly, the string &#8220;a&#8221; is not a function, causing this to fail. You can however <strong>quote</strong> the list to prevent evaluation, like this: <code>'("a" "b")</code>. Now we can use the list to store items without the first one being implemented.</p>

<p>Luckily, Clojure also has a <strong>vector</strong> which is best compared to an array. You can use it in place of a quoted list, and in fact it is idomatic to do so when you do not want the first item evaluated. Example <code>[1 2 3]</code></p>

<p>When you want to name something, you have different ways of doing so. The first one is <em>def</em>, you can use this to name stuff in the top level of a namespace. Example <code>(def foo [1 2 3])</code> This creates a vector named <em>foo</em> which you can then refer to from elsewhere. After typing in the previous example, you will see that now you can just type <code>foo</code> in the REPL and get the vector we have defined previously.</p>

<p>Or you can use the <strong>let-binding</strong> to name things locally, for example inside a function body, like so <code>(let [foo [1 2 3]])</code> Here, you can only refer to <em>foo</em> inside form. Let&#8217;s use <em>foo</em>: <code>(let [foo [1 2 3]] (print foo))</code> You should see the vector being printed in your REPL.</p>

<p>Functions can be defined as follows: <code>(fn [a] (+ a 1))</code> with this, we have defined a function that adds 1 to the specified argument.
You can use it as an anonymous function like this: <code>((fn [a] (+ a 1)) 2)</code> Remember, the first item in a list will be evaluated, and this happens to be the function we just defined. However, this is a little clumsy. We can also store the function in a def: <code>(def add-one (fn [a] (+ a 1)))</code> now we can call the function, like so <code>(add-one 2)</code>.</p>

<p>However, this can even be simpler using the <strong>defn macro</strong>, like so: <code>(defn add-one [a] (+ a 1))</code></p>

<p>Sometimes, you may want to create a function in place using the anonymous function literal, like so: <code>(#(+ % 1) 2)</code>. This does the same as the anymous function in the first position of the list as above, except for being shorter. During compilation, the <code>#(+ % 1)</code> expands into <code>(fn [a] (+ a 1))</code>, where the percent sign denotes the first argument. If there are multiple arguments, you use <em>%1</em>, <em>%2</em> and so on instead (1-based).</p>

<p><strong>TO BE CONTINUED</strong></p>

<h1>Application architecture</h1>

<p>Let us now have a look at the implementation details <sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>.</p>

<p>The most important part to understand is that the application state lives in one large <strong><a href="http://clojure.org/atoms">atom</a></strong>. When the application is started, this atom is populated with the return of a function that returns a map representing a clean slate. Here is how that looks like:</p>

<figure class='code'><figcaption><span>Function returning initial application state</span><a href='https://github.com/matthiasn/BirdWatch/blob/4eb23097ef0e375a5e69c3164cb39167f82c12f3/clients/cljs-om/src/cljs_om/util.cljs'>util.cljs</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">initial-state</span> <span class="p">[]</span>
</span><span class='line'>  <span class="s">&quot;function returning fresh application state&quot;</span>
</span><span class='line'>  <span class="p">{</span><span class="ss">:count</span> <span class="mi">0</span>
</span><span class='line'>   <span class="ss">:n</span> <span class="mi">10</span>
</span><span class='line'>   <span class="ss">:retweets</span> <span class="p">{}</span>
</span><span class='line'>   <span class="ss">:tweets-map</span> <span class="p">{}</span>
</span><span class='line'>   <span class="ss">:search-text</span> <span class="s">&quot;&quot;</span>
</span><span class='line'>   <span class="ss">:page</span> <span class="mi">1</span>
</span><span class='line'>   <span class="ss">:search</span> <span class="s">&quot;*&quot;</span>
</span><span class='line'>   <span class="ss">:stream</span> <span class="nv">nil</span>
</span><span class='line'>   <span class="ss">:sorted</span> <span class="ss">:by-rt-since-startup</span>
</span><span class='line'>   <span class="ss">:by-followers</span> <span class="p">(</span><span class="nf">priority-map-by</span> <span class="nv">&gt;</span><span class="p">)</span>
</span><span class='line'>   <span class="ss">:by-retweets</span> <span class="p">(</span><span class="nf">priority-map-by</span> <span class="nv">&gt;</span><span class="p">)</span>
</span><span class='line'>   <span class="ss">:by-favorites</span> <span class="p">(</span><span class="nf">priority-map-by</span> <span class="nv">&gt;</span><span class="p">)</span>
</span><span class='line'>   <span class="ss">:by-rt-since-startup</span> <span class="p">(</span><span class="nf">priority-map-by</span> <span class="nv">&gt;</span><span class="p">)</span>
</span><span class='line'>   <span class="ss">:by-id</span> <span class="p">(</span><span class="nf">priority-map-by</span> <span class="nv">&gt;</span><span class="p">)</span>
</span><span class='line'>   <span class="ss">:words-sorted-by-count</span> <span class="p">(</span><span class="nf">priority-map-by</span> <span class="nv">&gt;</span><span class="p">)})</span>
</span></code></pre></td></tr></table></div></figure>


<p>All the keys in this map are <strong><a href="http://clojure.org/data_structures#Data%20Structures-Keywords">keywords</a></strong>. Keywords have the great property that we can use them as functions that take a map as an argument and that then return the value for this key. We will see that in action below.</p>

<p>Upon startup of the application, the function above is called for populating the state atom:</p>

<figure class='code'><figcaption><span>Function returning initial application state</span><a href='https://github.com/matthiasn/BirdWatch/blob/4eb23097ef0e375a5e69c3164cb39167f82c12f3/clients/cljs-om/src/cljs_om/core.cljs'>core.cljs (lines 13 to 16)</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="c1">;;; Application state in a single atom</span>
</span><span class='line'><span class="c1">;;; Will be initialized with the map returned by util/initial-state.</span>
</span><span class='line'><span class="c1">;;; Reset to a new clean slate when a new search is started.</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">app-state</span> <span class="p">(</span><span class="nf">atom</span> <span class="p">(</span><span class="nf">util/initial-state</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Then the reference to this <strong><a href="http://clojure.org/atoms">atom</a></strong> is passed around, which is dereferenced wherever a change occurs and then updated back into the atom. It is important to note that clojure data structures are immutable. Immutability guarantees that you can pass data structures around without having to worry that whoever you pass it to might change the data. State changes only can only happen inside a transaction, a new and altered version of the state is passed back. The transaction part would also mean that no other process could alter state at the same time, in that case the later transaction would be retried when the first one has succeeded. This would be particularly useful when running in a multithreaded environment. However, the JavaScript code resulting from the ClojureScript compilation process runs in a single threaded event loop. In that environment, there&#8217;s only ever one thing happening at the same time anyway.</p>

<p>Using this map generated from a helper function makes it trivial to reset the application state at a later point <sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>, we can simply swap the current state with the clean slate map.</p>

<h2>Ingesting tweets</h2>

<p>Tweets get into the system for further analysis in two ways. First, there is a Server Sent Event stream continously delivering new matches to a query, with low latency (typically around a second between sending tweet and having it show up in the application). Then also previous tweets are loaded. Both are triggered in the <strong>start-search</strong> function:</p>

<figure class='code'><figcaption><span>start-search function</span><a href='https://github.com/matthiasn/BirdWatch/blob/4eb23097ef0e375a5e69c3164cb39167f82c12f3/clients/cljs-om/src/cljs_om/tweets.cljs'>tweets.cljs (lines 47 to 57)</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">start-search</span> <span class="p">[</span><span class="nv">app</span> <span class="nv">tweets-chan</span><span class="p">]</span>
</span><span class='line'>  <span class="s">&quot;initiate new search by starting SSE stream&quot;</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">search</span> <span class="p">(</span><span class="ss">:search-text</span> <span class="o">@</span><span class="nv">app</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">s</span> <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">= </span><span class="nv">search</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="s">&quot;*&quot;</span> <span class="nv">search</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nb">not </span><span class="p">(</span><span class="nb">nil? </span><span class="p">(</span><span class="ss">:stream</span> <span class="o">@</span><span class="nv">app</span><span class="p">)))</span> <span class="p">(</span><span class="nf">.close</span> <span class="p">(</span><span class="ss">:stream</span> <span class="o">@</span><span class="nv">app</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">reset!</span> <span class="nv">app</span> <span class="p">(</span><span class="nf">util/initial-state</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">swap!</span> <span class="nv">app</span> <span class="nb">assoc </span><span class="ss">:search</span> <span class="nv">s</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">aset </span><span class="nv">js/window</span> <span class="s">&quot;location&quot;</span> <span class="s">&quot;hash&quot;</span> <span class="p">(</span><span class="nf">js/encodeURIComponent</span> <span class="nv">s</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">swap!</span> <span class="nv">app</span> <span class="nb">assoc </span><span class="ss">:stream</span> <span class="p">(</span><span class="nf">js/EventSource.</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;/tweetFeed?q=&quot;</span> <span class="nv">s</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">.addEventListener</span> <span class="p">(</span><span class="ss">:stream</span> <span class="o">@</span><span class="nv">app</span><span class="p">)</span> <span class="s">&quot;message&quot;</span> <span class="o">#</span><span class="p">(</span><span class="nf">receive-sse</span> <span class="nv">tweets-chan</span> <span class="nv">%</span><span class="p">)</span> <span class="nv">false</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">doall </span><span class="p">(</span><span class="nb">for </span><span class="p">[</span><span class="nv">x</span> <span class="p">(</span><span class="nb">range </span><span class="mi">5</span><span class="p">)]</span> <span class="p">(</span><span class="nf">ajax/prev-search</span> <span class="nv">s</span> <span class="mi">500</span> <span class="p">(</span><span class="nb">* </span><span class="mi">500</span> <span class="nv">x</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let us go through this line by line. The <strong>defn</strong> macro denotes a function named start-search which takes two arguments, <em>app</em> for a reference to the application state and <em>tweets-chan</em>, a channel where to put tweets. Channels are building blocks in <strong><a href="https://github.com/clojure/core.async">Core.async</a></strong>. We will get to that in a little bit, for now just think about a channel as a conveyor belt onto which one part of the application puts data. On the other end, another part of the application picks up the data, but the sender does not need to know about it. Broadly speaking, it is a sweet way to decouple an application.</p>

<p>In the next line there is the description of the function, followed by a <strong><a href="http://clojure.org/special_forms#binding-forms">let binding</a></strong> where we declare first two local immutable values, both of which are available for the remainder of the function. The first one, <em>search</em>, retrieves the value for the key <em>:search-text</em> in the application state. <em>@app</em> dereferences the application state, giving us an immutable copy of the current app state. <code>(:search-text @app)</code> will run the keyword as a function with the state map as an argument, returning the value in the map. Next we declare <em>s</em> whose value can take two paths as decided by the <strong><a href="http://clojure.org/special_forms#Special%20Forms--(if%20test%20then%20else?)">if special form</a></strong>. The if form consists of three parts. There is a test: <code>(= search "")</code>. Not surprisingly at this point, <strong>=</strong> is a function that evaluates if the arguments passed to it are equal, returning either true or false. The <strong>if</strong> form then either returns the expression right after the test if the test evaluated to <em>true</em> or the subsequent one if it evaluated to <em>false</em>. What we are doing here is simply replacing an empty string with an asterisk or otherwise just taking the search string.</p>

<p>Next, we close a previous Server Sent Event stream, should one exist. This is only required when resetting the application state as on initial startup the value for the <em>:stream</em> key will be nil. Then we reset the application state by replacing it with a clean state. Then we swap the value for the <em>:search</em> key with out local value <em>s</em>. Then we set the location hash to represent a URI encoded version of the search string.</p>

<p>In the next line, we create a new EventSource object for the live stream of tweets and store it under the <em>:stream</em> key, to which we attach a function as an event listener. We are using an anonymous function literal here because the <em>receive-sse</em> function takes two arguments (a channel and an event from the EventSource object) whereas the event listener requires a function that only takes a single argument. Then finally we call <em>ajax/prev-search</em> with 5 chunks of 500 results each, but we will look at that later. Let us for now focus on the <em>receive-sse</em> function:</p>

<figure class='code'><figcaption><span>receive-sse function</span><a href='https://github.com/matthiasn/BirdWatch/blob/4eb23097ef0e375a5e69c3164cb39167f82c12f3/clients/cljs-om/src/cljs_om/tweets.cljs'>tweets.cljs (lines 42 to 45)</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">receive-sse</span> <span class="p">[</span><span class="nv">tweets-chan</span> <span class="nv">e</span><span class="p">]</span>
</span><span class='line'>  <span class="s">&quot;callback, called for each item (tweet) received by SSE stream&quot;</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">tweet</span> <span class="p">(</span><span class="nf">js-&gt;clj</span> <span class="p">(</span><span class="nf">JSON/parse</span> <span class="p">(</span><span class="nf">.-data</span> <span class="nv">e</span><span class="p">))</span> <span class="ss">:keywordize-keys</span> <span class="nv">true</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">put!</span> <span class="nv">tweets-chan</span> <span class="nv">tweet</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is a function with two arguments, a channel and an event. In the <strong>let-binding</strong>, the event is parsed into a tweet. This reads inside out: 1) get event data 2) parse JSON into JavaScript object 3) convert JavaScript object into a Clojure(Script) Map. Note that for the conversion into a Clojure Map we can automatically have the keys converted into keywords using <em>:keywordize-keys true</em>. This is convenient as we can use the keywords as functions later for retrieving values for the respective key. Then the <em>tweet</em> from the let binding is <em>put!</em> onto the <em>tweets-chan</em>, this aforementioned conveyor belt.</p>

<p>Now is a good time to talk a little more about those channels. Channels are brought to Clojure by importing the <strong><a href="https://github.com/clojure/core.async">Core.async</a></strong> library. <strong>Core async</strong> is modeled after channels in the <strong><a href="http://golang.org">Go programming language</a></strong>, which implements <strong><a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating Sequential Processes</a></strong> or <strong>CSP</strong> for short. You really should watch <strong><a href="http://www.infoq.com/presentations/clojure-core-async">Rick Hickey&#8217;s talk about core.async</a></strong> now if you haven&#8217;t already.</p>

<p>I am really only scratching the surface of what can be achieved with CSP, but it does seem like a useful abstraction to decouple parts of an application. Besides the aforementioned <em>tweets-chan</em> there is also a channel for previous tweets, those that are retrieved using Ajax calls (we will cover that part next):</p>

<figure class='code'><figcaption><span>Channels</span><a href='https://github.com/matthiasn/BirdWatch/blob/4eb23097ef0e375a5e69c3164cb39167f82c12f3/clients/cljs-om/src/cljs_om/core.cljs'>core.cljs (lines 37 to 44)</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="c1">;;; Channels for handling information flow in the application.</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">tweets-chan</span> <span class="p">(</span><span class="nf">chan</span> <span class="mi">10000</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">prev-tweets-chan</span> <span class="p">(</span><span class="nf">chan</span> <span class="mi">10000</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="nf">go-loop</span> <span class="p">[]</span>
</span><span class='line'> <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">t</span> <span class="nv">chan</span><span class="p">]</span> <span class="p">(</span><span class="nf">alts!</span> <span class="p">[</span><span class="nv">tweets-chan</span> <span class="nv">prev-tweets-chan</span><span class="p">]</span> <span class="ss">:priority</span><span class="p">)]</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">tweets/add-tweet</span> <span class="nv">t</span> <span class="nv">app-state</span> <span class="nv">word-cloud</span><span class="p">)</span>
</span><span class='line'>   <span class="p">(</span><span class="nf">recur</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Above, two channels are defined. Then, inside the <em>go-block</em>, <em>alts!</em> with <em>:priority</em> takes the one of the items from the two channels, with priority on the first one. That is because live tweets shall always be processed immediately whereas previous results can wait. With this item <em>t</em> taken from one of the channels, the <em>add-tweet</em> function in the <em>tweets</em> namespace is called. Finally, the go-loop runs continously using <em>recur</em>.</p>

<p>Before looking at the <em>tweets</em> namespace, let us have a quick look at the ajax call performed in the <em>start-search</em> function above:</p>

<figure class='code'><figcaption><span>Ajax</span><a href='https://github.com/matthiasn/BirdWatch/blob/4eb23097ef0e375a5e69c3164cb39167f82c12f3/clients/cljs-om/src/cljs_om/ajax.cljs'>core.cljs (lines 35 to 40)</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">prev-search</span> <span class="p">[</span><span class="nv">query-string</span> <span class="nv">size</span> <span class="nv">from</span><span class="p">]</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">json-xhr</span>
</span><span class='line'>    <span class="p">{</span><span class="ss">:method</span> <span class="ss">:post</span>
</span><span class='line'>     <span class="ss">:url</span> <span class="s">&quot;/tweets/search&quot;</span>
</span><span class='line'>     <span class="ss">:data</span> <span class="p">(</span><span class="nf">query</span> <span class="nv">query-string</span> <span class="nv">size</span> <span class="nv">from</span><span class="p">)</span>
</span><span class='line'>     <span class="ss">:on-complete</span> <span class="o">#</span><span class="p">(</span><span class="nf">put!</span> <span class="nv">ajax-results-chan</span> <span class="nv">%</span><span class="p">)}))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Above, we see a function that takes a query string, the expected number of items in the result and an offset. What it then does is call <em>json-xhr</em> from the imported <strong><a href="http://docs.closure-library.googlecode.com/git/class_goog_net_XhrIo.html">goog.net.XhrIo</a></strong> with a map specifying method, url, data and an event handler. <strong>XhrIo</strong> comes with <strong><a href="https://developers.google.com/closure/compiler/">Google&#8217;s Closure Compiler</a></strong> that is used in the ClojureScript to JavaScript compilation process.</p>

<p>The query itself is generated by the <em>query</em> function in the same namespace:</p>

<figure class='code'><figcaption><span>Ajax</span><a href='https://github.com/matthiasn/BirdWatch/blob/4eb23097ef0e375a5e69c3164cb39167f82c12f3/clients/cljs-om/src/cljs_om/ajax.cljs'>core.cljs (lines 19 to 23)</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">query</span> <span class="p">[</span><span class="nv">query-string</span> <span class="nv">size</span> <span class="nv">from</span><span class="p">]</span>
</span><span class='line'>  <span class="p">{</span><span class="ss">:size</span> <span class="nv">size</span> <span class="ss">:from</span> <span class="nv">from</span>
</span><span class='line'>   <span class="ss">:sort</span> <span class="p">{</span><span class="ss">:id</span> <span class="s">&quot;desc&quot;</span><span class="p">}</span>
</span><span class='line'>   <span class="ss">:query</span> <span class="p">{</span><span class="ss">:query_string</span> <span class="p">{</span><span class="ss">:default_field</span> <span class="s">&quot;text&quot;</span> <span class="ss">:default_operator</span> <span class="s">&quot;AND&quot;</span>
</span><span class='line'>                          <span class="ss">:query</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;(&quot;</span> <span class="nv">query-string</span> <span class="s">&quot;) AND lang:en&quot;</span><span class="p">)}}})</span>
</span></code></pre></td></tr></table></div></figure>


<p>This function generates the map with the required properties for the ElasticSearch query on the server side. This query will eventually go on the wire as JSON.</p>

<p>Then finally as an event handler there is an anonymous function literal putting the result onto another channel for the Ajax results:</p>

<figure class='code'><figcaption><span>Ajax results channel and Go Loop</span><a href='https://github.com/matthiasn/BirdWatch/blob/4eb23097ef0e375a5e69c3164cb39167f82c12f3/clients/cljs-om/src/cljs_om/ajax.cljs'>core.cljs (lines 11 to 17)</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">ajax-results-chan</span> <span class="p">(</span><span class="nf">chan</span><span class="p">))</span>
</span><span class='line'><span class="p">(</span><span class="nf">go-loop</span> <span class="p">[]</span>
</span><span class='line'>         <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">parsed</span> <span class="p">(</span><span class="nf">js-&gt;clj</span> <span class="p">(</span><span class="nf">JSON/parse</span> <span class="p">(</span><span class="nf">&lt;!</span> <span class="nv">ajax-results-chan</span><span class="p">))</span> <span class="ss">:keywordize-keys</span> <span class="nv">true</span><span class="p">)]</span>
</span><span class='line'>           <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">t</span> <span class="p">(</span><span class="ss">:hits</span> <span class="p">(</span><span class="ss">:hits</span> <span class="nv">parsed</span><span class="p">))]</span>
</span><span class='line'>             <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">= </span><span class="mi">0</span> <span class="p">(</span><span class="nf">mod</span> <span class="p">(</span><span class="ss">:_id</span> <span class="nv">t</span><span class="p">)</span> <span class="mi">200</span><span class="p">))</span> <span class="p">(</span><span class="nf">&lt;!</span> <span class="p">(</span><span class="nf">timeout</span> <span class="mi">10</span><span class="p">)))</span>
</span><span class='line'>             <span class="p">(</span><span class="nf">put!</span> <span class="nv">cljs-om.core/prev-tweets-chan</span> <span class="p">(</span><span class="ss">:_source</span> <span class="nv">t</span><span class="p">)))</span>
</span><span class='line'>           <span class="p">(</span><span class="nf">recur</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>Above, the JSON for each item on the channel is parsed into a Clojure(Script) data structure, where <em>parsed</em> is a vector. Then, each item in that vector is put! onto the prev-tweets-chan. Rather, the value for the <em>:_source</em> key is used here as that is where ElasticSearch stores the original item. One thing to note here is the usage of a <strong><a href="https://clojure.github.io/core.async/#clojure.core.async/timeout">timeout</a></strong> roughly every 200 tweets. I have introduced this in order to occasionally return control to the <strong><a href="http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/">JavaScript Event Loop</a></strong> so that a) the UI gets rendered and b) the event listener for tweets from the Server Sent Event stream can do its thing. Otherwise, the application just appears to halt until all previous tweets are processed, which is really annoying. But this seems rather hacky, I would be really curious about solving this problem more elegantly.</p>

<p>With the preloading of tweets using Ajax calls covered, we can now proceed to the processing of tweets inside the <em>tweets</em> namespace. As we have seen before with the go loop alternating between channels, <em>add-tweet</em> is called for each tweet coming into the application:</p>

<figure class='code'><figcaption><span>add-tweet function</span><a href='https://github.com/matthiasn/BirdWatch/blob/4eb23097ef0e375a5e69c3164cb39167f82c12f3/clients/cljs-om/src/cljs_om/tweets.cljs'>tweets.cljs (lines 31 to 40)</a></figcaption> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">add-tweet</span> <span class="p">[</span><span class="nv">tweet</span> <span class="nv">app</span> <span class="nv">word-cloud</span><span class="p">]</span>
</span><span class='line'>  <span class="s">&quot;increment counter, add tweet to tweets map and to sorted sets by id and by followers&quot;</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">state</span> <span class="o">@</span><span class="nv">app</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">swap!</span> <span class="nv">app</span> <span class="nb">assoc </span><span class="ss">:count</span> <span class="p">(</span><span class="nb">inc </span><span class="p">(</span><span class="ss">:count</span> <span class="nv">state</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">add-to-tweets-map</span> <span class="nv">app</span> <span class="ss">:tweets-map</span> <span class="p">(</span><span class="nf">util/format-tweet</span> <span class="nv">tweet</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">util/swap-pmap</span> <span class="nv">app</span> <span class="ss">:by-followers</span> <span class="p">(</span><span class="nb">keyword </span><span class="p">(</span><span class="ss">:id_str</span> <span class="nv">tweet</span><span class="p">))</span> <span class="p">(</span><span class="ss">:followers_count</span> <span class="p">(</span><span class="ss">:user</span> <span class="nv">tweet</span><span class="p">)))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">util/swap-pmap</span> <span class="nv">app</span> <span class="ss">:by-id</span> <span class="p">(</span><span class="nb">keyword </span><span class="p">(</span><span class="ss">:id_str</span> <span class="nv">tweet</span><span class="p">))</span> <span class="p">(</span><span class="ss">:id</span> <span class="nv">tweet</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">add-rt-status</span> <span class="nv">app</span> <span class="nv">tweet</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">wc/process-tweet</span> <span class="nv">app</span> <span class="p">(</span><span class="ss">:text</span> <span class="nv">tweet</span><span class="p">))</span>
</span><span class='line'>    <span class="p">(</span><span class="k">. </span><span class="nv">word-cloud</span> <span class="p">(</span><span class="nf">redraw</span> <span class="p">(</span><span class="nf">clj-&gt;js</span> <span class="p">(</span><span class="nf">wc/get-words</span> <span class="nv">app</span> <span class="mi">250</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>First of all, for each new tweet, the counter inside the application state is swapped with the number incremented by one. Then, <strong>add-to-tweets-map</strong> is called (described below), which as the name suggests adds the current tweet to the map that is found under the <em>:tweets-map</em> key in the application state. Before being added, each tweet is also processed, in that step for example user mentions and links are replaced with the correct HTML representation.</p>

<p>For a better understanding: the application allows displaying the tweets in different sort orders. Priority maps are used for maintaining the sort order. These priority maps contain nothing more than the ID of the tweet and whatever that specific map is sorted on, i.e. the number of followers. The full tweets are stored in one map with the ID of a tweet as the key and the tweet itself as the value. For displaying a sorted list of tweets in the UI, a sorted vector from the priority map is mapped by looking up each item in <em>:tweets-map</em> and using that item instead of the sorted value.</p>

<p><strong>TO BE CONTINUED</strong></p>

<h1>Summary</h1>

<p>Overall I find working with Clojure(Script) quite pleasant. However I still need to understand how to better structure an application as I am not completely happy with the current architecture yet. But that will hopefully improve.</p>

<p>Please comment and suggest any improvement you can think of, including typos and difficult to understand sentences. This is a work in progress, and a rather early draft at that. Any help is certainly welcome.</p>

<p>Cheers,
Matthias</p>
<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>Actually I should mention <strong><a href="http://lodash.com">Lo-Dash</a></strong> instead of <strong>underscore</strong>. I use it as a drop-in replacement for underscore especially for one reason and that is <strong><a href="http://lodash.com/docs#cloneDeep">_.cloneDeep</a></strong>. The ability to deep clone a data structure makes developing an undo functionality much, much, much easier. Not as trivial as with <strong><a href="http://swannodette.github.io/2013/12/31/time-travel/">ClojureScript</a></strong> or with <strong><a href="/01/24/scala-dot-js-and-reactjs/">Scala.js</a></strong> but it is not difficult, either.<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>Please let me know if you do not understand everything in here or have suggestions on how to make it simpler.<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
<li id="fn:3">
<p>I might edit this article should a better architecture evolve.<a href="#fnref:3" rev="footnote">&#8617;</a></p></li>
<li id="fn:4">
<p>That is not completely true here. The application makes use of channels for processing both previous and current tweets. What if there is still stuff on channels when the reset takes place? This still needs to be solved.<a href="#fnref:4" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Matthias Nehlsen</span></span>

      








  


<time datetime="2014-07-24T08:30:00+02:00" pubdate data-updated="true">07/24/2014</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://matthiasnehlsen.com/blog/2014/07/24/BirdWatch-in-ClojureScript-1/" data-via="matthiasnehlsen" data-counturl="http://matthiasnehlsen.com/blog/2014/07/24/BirdWatch-in-ClojureScript-1/" >Tweet</a>
  

  
  <div class="g-plusone" data-size="medium"></div>
  

  
  
  
  
  <br />
  
  
    <div class="fb-like" data-send="true" data-width="600" data-show-faces="false"></div>
  
  
  <br />
  <br />
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/07/17/BirdWatch-in-ClojureScript/" title="Previous Post: BirdWatch client using ClojureScript and Om">&laquo; BirdWatch client using ClojureScript and Om</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    
<section>
	<span>
		<img src="http://www.gravatar.com/avatar/3f6cb2a9b1057c35f284174063835d41?s=250" alt="Gravatar of Matthias Nehlsen " title="Gravatar of Matthias Nehlsen" />
	</span>
</section>
<section>
  <h1>About Me</h1>
  <p>Hello everyone. My name is Matthias Nehlsen and I am exploring functional programming, data visualization and real-time information processing.</p>
</section>

<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/07/24/BirdWatch-in-ClojureScript-1/">BirdWatch with ClojureScript and Om explained, Part 1</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/17/BirdWatch-in-ClojureScript/">BirdWatch client using ClojureScript and Om</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/08/hamburg-angularjs-meetup/">New AngularJS Meetup in Hamburg</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/06/distributed-barometer/">Distributed Atmospheric Pressure Measurement</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/02/new-approach/">Updated Approach</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li><a href="https://github.com/matthiasn/birdwatch">BirdWatch</a>&nbsp;
      <iframe src="http://ghbtns.com/github-btn.html?user=matthiasn&repo=birdwatch&type=watch&count=true"
        allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe>
      <p>Reactive web application using Play Framework 2.2 for consuming and visualizing live Tweets from the Twitter Streaming API.</p>
    </li>
    <li><a href="https://github.com/matthiasn/sse-chat">sse-chat</a>&nbsp;
      <iframe src="http://ghbtns.com/github-btn.html?user=matthiasn&repo=sse-chat&type=watch&count=true"
        allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe>
      <p>Chat example app using Server Sent Events plus REST calls. Client side implementations both in AngularJS and in React.</p>
    </li>
    <li><a href="https://github.com/matthiasn/sse-perf">sse-perf</a>&nbsp;
      <iframe src="http://ghbtns.com/github-btn.html?user=matthiasn&repo=sse-perf&type=watch&count=true"
        allowtransparency="true" frameborder="0" scrolling="0" width="110" height="20"></iframe>
      <p>Reactive web application using Play Framework 2.1 for load testing Server Sent Event streams (or other HTTP connections that deliver information in chunks).</p>
    </li>
  </ul>
</section>
<section>
    <a name="signup"><h1>Subscribe</h1></a>
    <div id="mc_embed_signup">
      <form action="http://matthiasnehlsen.us7.list-manage1.com/subscribe/post?u=798fd7b50a1d9cc58be41c2af&amp;id=eb7a7193c5" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate>
        <div class="mc-field-group">
          <label for="mce-EMAIL">Enter your email to receive updates</label>
          <input type="email" value="" name="EMAIL" class="required email" id="mce-EMAIL" placeholder="you@email.com" />
        </div>
        <div id="mce-responses" class="clear">
          <div class="response" id="mce-error-response" style="display:none"></div>
          <div class="response" id="mce-success-response" style="display:none"></div>
        </div>
      <div class="clear"><input type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe" class="button"></div>
    </form>
    
    <br />
  </div>
</section>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Matthias Nehlsen -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'matthiasnehlsen';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://matthiasnehlsen.com/blog/2014/07/24/BirdWatch-in-ClojureScript-1/';
        var disqus_url = 'http://matthiasnehlsen.com/blog/2014/07/24/BirdWatch-in-ClojureScript-1/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>



  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
